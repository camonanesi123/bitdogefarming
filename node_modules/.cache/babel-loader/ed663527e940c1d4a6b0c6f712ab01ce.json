{"ast":null,"code":"/* eslint-disable no-param-reassign */\nimport { createAsyncThunk, createSlice } from '@reduxjs/toolkit';\nimport { nftSources } from 'config/constants/nfts';\nimport { getAddress } from 'utils/addressHelpers';\nimport { getErc721Contract } from 'utils/contractHelpers';\nimport { getNftByTokenId } from 'utils/collectibles';\nconst initialState = {\n  isInitialized: false,\n  isLoading: true,\n  data: {}\n};\n// Thunks\nexport const fetchWalletNfts = createAsyncThunk('collectibles/fetchWalletNfts', async account => {\n  // For each nft source get nft data\n  const nftSourcePromises = Object.keys(nftSources).map(async nftSourceType => {\n    const {\n      address: addressObj\n    } = nftSources[nftSourceType];\n    const address = getAddress(addressObj);\n    const contract = getErc721Contract(address);\n\n    const getTokenIdAndData = async index => {\n      try {\n        const tokenId = await contract.methods.tokenOfOwnerByIndex(account, index).call();\n        const walletNft = await getNftByTokenId(address, tokenId);\n        return [Number(tokenId), walletNft.identifier];\n      } catch (error) {\n        console.error('getTokenIdAndData', error);\n        return null;\n      }\n    };\n\n    const balanceOfResponse = await contract.methods.balanceOf(account).call();\n    const balanceOf = Number(balanceOfResponse);\n\n    if (balanceOf === 0) {\n      return [];\n    }\n\n    const nftDataFetchPromises = []; // For each index get the tokenId and data associated with it\n\n    for (let i = 0; i < balanceOf; i++) {\n      nftDataFetchPromises.push(getTokenIdAndData(i));\n    }\n\n    const nftData = await Promise.all(nftDataFetchPromises);\n    return nftData;\n  });\n  const nftSourceData = await Promise.all(nftSourcePromises);\n  return nftSourceData.flat();\n});\nexport const collectiblesSlice = createSlice({\n  name: 'collectibles',\n  initialState,\n  reducers: {},\n  extraReducers: builder => {\n    builder.addCase(fetchWalletNfts.pending, state => {\n      state.isLoading = true;\n    });\n    builder.addCase(fetchWalletNfts.fulfilled, (state, action) => {\n      state.isLoading = false;\n      state.isInitialized = true;\n      state.data = action.payload.reduce((accum, association) => {\n        if (!association) {\n          return accum;\n        }\n\n        const [tokenId, identifier] = association;\n        return { ...accum,\n          [identifier]: accum[identifier] ? [...accum[identifier], tokenId] : [tokenId]\n        };\n      }, {});\n    });\n  }\n});\nexport default collectiblesSlice.reducer;","map":{"version":3,"sources":["D:/task159/frontend/src/state/collectibles/index.ts"],"names":["createAsyncThunk","createSlice","nftSources","getAddress","getErc721Contract","getNftByTokenId","initialState","isInitialized","isLoading","data","fetchWalletNfts","account","nftSourcePromises","Object","keys","map","nftSourceType","address","addressObj","contract","getTokenIdAndData","index","tokenId","methods","tokenOfOwnerByIndex","call","walletNft","Number","identifier","error","console","balanceOfResponse","balanceOf","nftDataFetchPromises","i","push","nftData","Promise","all","nftSourceData","flat","collectiblesSlice","name","reducers","extraReducers","builder","addCase","pending","state","fulfilled","action","payload","reduce","accum","association","reducer"],"mappings":"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","sourcesContent":["/* eslint-disable no-param-reassign */\nimport { createAsyncThunk, createSlice } from '@reduxjs/toolkit'\nimport { CollectiblesState } from 'state/types'\nimport { nftSources } from 'config/constants/nfts'\nimport { NftType } from 'config/constants/types'\nimport { getAddress } from 'utils/addressHelpers'\nimport { getErc721Contract } from 'utils/contractHelpers'\nimport { getNftByTokenId } from 'utils/collectibles'\n\nconst initialState: CollectiblesState = {\n  isInitialized: false,\n  isLoading: true,\n  data: {},\n}\n\ntype NftSourceItem = [number, string]\n\n// Thunks\nexport const fetchWalletNfts = createAsyncThunk<NftSourceItem[], string>(\n  'collectibles/fetchWalletNfts',\n  async (account) => {\n    // For each nft source get nft data\n    const nftSourcePromises = Object.keys(nftSources).map(async (nftSourceType) => {\n      const { address: addressObj } = nftSources[nftSourceType as NftType]\n      const address = getAddress(addressObj)\n\n      const contract = getErc721Contract(address)\n\n      const getTokenIdAndData = async (index: number) => {\n        try {\n          const tokenId = await contract.methods.tokenOfOwnerByIndex(account, index).call()\n          const walletNft = await getNftByTokenId(address, tokenId)\n          return [Number(tokenId), walletNft.identifier]\n        } catch (error) {\n          console.error('getTokenIdAndData', error)\n          return null\n        }\n      }\n\n      const balanceOfResponse = await contract.methods.balanceOf(account).call()\n      const balanceOf = Number(balanceOfResponse)\n\n      if (balanceOf === 0) {\n        return []\n      }\n\n      const nftDataFetchPromises = []\n\n      // For each index get the tokenId and data associated with it\n      for (let i = 0; i < balanceOf; i++) {\n        nftDataFetchPromises.push(getTokenIdAndData(i))\n      }\n\n      const nftData = await Promise.all(nftDataFetchPromises)\n      return nftData\n    })\n\n    const nftSourceData = await Promise.all(nftSourcePromises)\n\n    return nftSourceData.flat()\n  },\n)\n\nexport const collectiblesSlice = createSlice({\n  name: 'collectibles',\n  initialState,\n  reducers: {},\n  extraReducers: (builder) => {\n    builder.addCase(fetchWalletNfts.pending, (state) => {\n      state.isLoading = true\n    })\n    builder.addCase(fetchWalletNfts.fulfilled, (state, action) => {\n      state.isLoading = false\n      state.isInitialized = true\n      state.data = action.payload.reduce((accum, association) => {\n        if (!association) {\n          return accum\n        }\n\n        const [tokenId, identifier] = association as NftSourceItem\n\n        return {\n          ...accum,\n          [identifier]: accum[identifier] ? [...accum[identifier], tokenId] : [tokenId],\n        }\n      }, {})\n    })\n  },\n})\n\nexport default collectiblesSlice.reducer\n"]},"metadata":{},"sourceType":"module"}