{"ast":null,"code":"import _regeneratorRuntime from\"D:/task159/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";import _asyncToGenerator from\"D:/task159/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";import Nfts,{nftSources}from'config/constants/nfts';import{getAddress}from'./addressHelpers';import{getErc721Contract}from'./contractHelpers';/**\n * Gets the identifier key based on the nft address\n * Helpful for looking up the key when all you have is the address\n */export var getIdentifierKeyFromAddress=function getIdentifierKeyFromAddress(nftAddress){var nftSource=Object.values(nftSources).find(function(nftSourceEntry){var address=getAddress(nftSourceEntry.address);return address===nftAddress;});return nftSource?nftSource.identifierKey:null;};/**\n * Some sources like Pancake do not return HTTP tokenURI's\n */export var getTokenUrl=function getTokenUrl(tokenUri){// if (tokenUri.startsWith('ipfs://')) {\n//   return `${IPFS_GATEWAY}/ipfs/${tokenUri.slice(6)}`\n// }\nreturn tokenUri;};export var getAddressByType=function getAddressByType(type){return getAddress(nftSources[type].address);};export var getTokenUriData=/*#__PURE__*/function(){var _ref=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee(nftAddress,tokenId){var contract,tokenUri,uriDataResponse,uriData;return _regeneratorRuntime.wrap(function _callee$(_context){while(1){switch(_context.prev=_context.next){case 0:_context.prev=0;contract=getErc721Contract(nftAddress);_context.next=4;return contract.methods.tokenURI(tokenId).call();case 4:tokenUri=_context.sent;_context.next=7;return fetch(getTokenUrl(tokenUri));case 7:uriDataResponse=_context.sent;_context.next=10;return uriDataResponse.json();case 10:uriData=_context.sent;return _context.abrupt(\"return\",uriData);case 14:_context.prev=14;_context.t0=_context[\"catch\"](0);console.error('getTokenUriData',_context.t0);return _context.abrupt(\"return\",null);case 18:case\"end\":return _context.stop();}}},_callee,null,[[0,14]]);}));return function getTokenUriData(_x,_x2){return _ref.apply(this,arguments);};}();export var getNftByTokenId=/*#__PURE__*/function(){var _ref2=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee2(nftAddress,tokenId){var uriData,identifierKey;return _regeneratorRuntime.wrap(function _callee2$(_context2){while(1){switch(_context2.prev=_context2.next){case 0:_context2.next=2;return getTokenUriData(nftAddress,tokenId);case 2:uriData=_context2.sent;identifierKey=getIdentifierKeyFromAddress(nftAddress);// Bail out early if we have no uriData, identifierKey, or the value does not\n// exist in the object\n// if (!uriData) {\n//   return null\n// }\n// if (!identifierKey) {\n//   return null\n// }\n// if (!uriData[identifierKey]) {\n//   return null\n// }\n// return Nfts.find((nft) => {\n//   return uriData[identifierKey].includes(nft.identifier)\n// })\nreturn _context2.abrupt(\"return\",Nfts.find(function(nft){return nft.identifier==='Dragon';}));case 5:case\"end\":return _context2.stop();}}},_callee2);}));return function getNftByTokenId(_x3,_x4){return _ref2.apply(this,arguments);};}();","map":{"version":3,"sources":["D:/task159/frontend/src/utils/collectibles.ts"],"names":["Nfts","nftSources","getAddress","getErc721Contract","getIdentifierKeyFromAddress","nftAddress","nftSource","Object","values","find","nftSourceEntry","address","identifierKey","getTokenUrl","tokenUri","getAddressByType","type","getTokenUriData","tokenId","contract","methods","tokenURI","call","fetch","uriDataResponse","json","uriData","console","error","getNftByTokenId","nft","identifier"],"mappings":"iRAAA,MAAOA,CAAAA,IAAP,EAA6BC,UAA7B,KAA+C,uBAA/C,CAEA,OAASC,UAAT,KAA2B,kBAA3B,CACA,OAASC,iBAAT,KAAkC,mBAAlC,CAEA;AACA;AACA;AACA,GACA,MAAO,IAAMC,CAAAA,2BAA2B,CAAG,QAA9BA,CAAAA,2BAA8B,CAACC,UAAD,CAAwB,CACjE,GAAMC,CAAAA,SAAS,CAAGC,MAAM,CAACC,MAAP,CAAcP,UAAd,EAA0BQ,IAA1B,CAA+B,SAACC,cAAD,CAAoB,CACnE,GAAMC,CAAAA,OAAO,CAAGT,UAAU,CAACQ,cAAc,CAACC,OAAhB,CAA1B,CACA,MAAOA,CAAAA,OAAO,GAAKN,UAAnB,CACD,CAHiB,CAAlB,CAKA,MAAOC,CAAAA,SAAS,CAAGA,SAAS,CAACM,aAAb,CAA6B,IAA7C,CACD,CAPM,CASP;AACA;AACA,GACA,MAAO,IAAMC,CAAAA,WAAW,CAAG,QAAdA,CAAAA,WAAc,CAACC,QAAD,CAAsB,CAC/C;AACA;AACA;AAEA,MAAOA,CAAAA,QAAP,CACD,CANM,CAQP,MAAO,IAAMC,CAAAA,gBAAgB,CAAG,QAAnBA,CAAAA,gBAAmB,CAACC,IAAD,CAAmB,CACjD,MAAOd,CAAAA,UAAU,CAACD,UAAU,CAACe,IAAD,CAAV,CAAiBL,OAAlB,CAAjB,CACD,CAFM,CAIP,MAAO,IAAMM,CAAAA,eAAe,0FAAG,iBAAOZ,UAAP,CAA2Ba,OAA3B,gLAErBC,QAFqB,CAEVhB,iBAAiB,CAACE,UAAD,CAFP,uBAGJc,CAAAA,QAAQ,CAACC,OAAT,CAAiBC,QAAjB,CAA0BH,OAA1B,EAAmCI,IAAnC,EAHI,QAGrBR,QAHqB,qCAIGS,CAAAA,KAAK,CAACV,WAAW,CAACC,QAAD,CAAZ,CAJR,QAIrBU,eAJqB,sCAULA,CAAAA,eAAe,CAACC,IAAhB,EAVK,SAUrBC,OAVqB,+CAWpBA,OAXoB,4DAa3BC,OAAO,CAACC,KAAR,CAAc,iBAAd,cAb2B,gCAcpB,IAdoB,uEAAH,kBAAfX,CAAAA,eAAe,gDAArB,CAkBP,MAAO,IAAMY,CAAAA,eAAe,2FAAG,kBAAOxB,UAAP,CAA2Ba,OAA3B,uKACPD,CAAAA,eAAe,CAACZ,UAAD,CAAaa,OAAb,CADR,QACvBQ,OADuB,gBAEvBd,aAFuB,CAEPR,2BAA2B,CAACC,UAAD,CAFpB,CAI7B;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAGA;AACA;AACA;AArB6B,iCAuBtBL,IAAI,CAACS,IAAL,CAAU,SAACqB,GAAD,CAAS,CACxB,MAAOA,CAAAA,GAAG,CAACC,UAAJ,GAAmB,QAA1B,CACD,CAFM,CAvBsB,0DAAH,kBAAfF,CAAAA,eAAe,kDAArB","sourcesContent":["import Nfts, { IPFS_GATEWAY, nftSources } from 'config/constants/nfts'\nimport { Nft, NftType } from 'config/constants/types'\nimport { getAddress } from './addressHelpers'\nimport { getErc721Contract } from './contractHelpers'\n\n/**\n * Gets the identifier key based on the nft address\n * Helpful for looking up the key when all you have is the address\n */\nexport const getIdentifierKeyFromAddress = (nftAddress: string) => {\n  const nftSource = Object.values(nftSources).find((nftSourceEntry) => {\n    const address = getAddress(nftSourceEntry.address)\n    return address === nftAddress\n  })\n\n  return nftSource ? nftSource.identifierKey : null\n}\n\n/**\n * Some sources like Pancake do not return HTTP tokenURI's\n */\nexport const getTokenUrl = (tokenUri: string) => {\n  // if (tokenUri.startsWith('ipfs://')) {\n  //   return `${IPFS_GATEWAY}/ipfs/${tokenUri.slice(6)}`\n  // }\n  \n  return tokenUri\n}\n\nexport const getAddressByType = (type: NftType) => {\n  return getAddress(nftSources[type].address)\n}\n\nexport const getTokenUriData = async (nftAddress: string, tokenId: number) => {\n  try {\n    const contract = getErc721Contract(nftAddress)\n    const tokenUri = await contract.methods.tokenURI(tokenId).call()\n    const uriDataResponse = await fetch(getTokenUrl(tokenUri))\n\n    // if (!uriDataResponse.ok) {\n    //   return null\n    // }\n    \n    const uriData = await uriDataResponse.json()\n    return uriData\n  } catch (error) {\n    console.error('getTokenUriData', error)\n    return null\n  }\n}\n\nexport const getNftByTokenId = async (nftAddress: string, tokenId: number): Promise<Nft | null> => {\n  const uriData = await getTokenUriData(nftAddress, tokenId)\n  const identifierKey = getIdentifierKeyFromAddress(nftAddress)\n  \n  // Bail out early if we have no uriData, identifierKey, or the value does not\n  // exist in the object\n  // if (!uriData) {\n  //   return null\n  // }\n\n  // if (!identifierKey) {\n  //   return null\n  // }\n\n  // if (!uriData[identifierKey]) {\n  //   return null\n  // }\n\n  \n  // return Nfts.find((nft) => {\n  //   return uriData[identifierKey].includes(nft.identifier)\n  // })\n\n  return Nfts.find((nft) => {\n    return nft.identifier === 'Dragon'\n  })\n}\n"]},"metadata":{},"sourceType":"module"}