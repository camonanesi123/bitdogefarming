{"ast":null,"code":"import Nfts, { nftSources } from 'config/constants/nfts';\nimport { getAddress } from './addressHelpers';\nimport { getErc721Contract } from './contractHelpers';\n/**\n * Gets the identifier key based on the nft address\n * Helpful for looking up the key when all you have is the address\n */\n\nexport const getIdentifierKeyFromAddress = nftAddress => {\n  const nftSource = Object.values(nftSources).find(nftSourceEntry => {\n    const address = getAddress(nftSourceEntry.address);\n    return address === nftAddress;\n  });\n  return nftSource ? nftSource.identifierKey : null;\n};\n/**\n * Some sources like Pancake do not return HTTP tokenURI's\n */\n\nexport const getTokenUrl = tokenUri => {\n  // if (tokenUri.startsWith('ipfs://')) {\n  //   return `${IPFS_GATEWAY}/ipfs/${tokenUri.slice(6)}`\n  // }\n  return tokenUri;\n};\nexport const getAddressByType = type => {\n  return getAddress(nftSources[type].address);\n};\nexport const getTokenUriData = async (nftAddress, tokenId) => {\n  try {\n    const contract = getErc721Contract(nftAddress);\n    const tokenUri = await contract.methods.tokenURI(tokenId).call();\n    const uriDataResponse = await fetch(getTokenUrl(tokenUri)); // if (!uriDataResponse.ok) {\n    //   return null\n    // }\n\n    const uriData = await uriDataResponse.json();\n    return uriData;\n  } catch (error) {\n    console.error('getTokenUriData', error);\n    return null;\n  }\n};\nexport const getNftByTokenId = async (nftAddress, tokenId) => {\n  const uriData = await getTokenUriData(nftAddress, tokenId);\n  const identifierKey = getIdentifierKeyFromAddress(nftAddress); // Bail out early if we have no uriData, identifierKey, or the value does not\n  // exist in the object\n  // if (!uriData) {\n  //   return null\n  // }\n  // if (!identifierKey) {\n  //   return null\n  // }\n  // if (!uriData[identifierKey]) {\n  //   return null\n  // }\n  // return Nfts.find((nft) => {\n  //   return uriData[identifierKey].includes(nft.identifier)\n  // })\n\n  return Nfts.find(nft => {\n    return nft.identifier === 'Dragon';\n  });\n};","map":{"version":3,"sources":["D:/task159/frontend/src/utils/collectibles.ts"],"names":["Nfts","nftSources","getAddress","getErc721Contract","getIdentifierKeyFromAddress","nftAddress","nftSource","Object","values","find","nftSourceEntry","address","identifierKey","getTokenUrl","tokenUri","getAddressByType","type","getTokenUriData","tokenId","contract","methods","tokenURI","call","uriDataResponse","fetch","uriData","json","error","console","getNftByTokenId","nft","identifier"],"mappings":"AAAA,OAAOA,IAAP,IAA6BC,UAA7B,QAA+C,uBAA/C;AAEA,SAASC,UAAT,QAA2B,kBAA3B;AACA,SAASC,iBAAT,QAAkC,mBAAlC;AAEA;AACA;AACA;AACA;;AACA,OAAO,MAAMC,2BAA2B,GAAIC,UAAD,IAAwB;AACjE,QAAMC,SAAS,GAAGC,MAAM,CAACC,MAAP,CAAcP,UAAd,EAA0BQ,IAA1B,CAAgCC,cAAD,IAAoB;AACnE,UAAMC,OAAO,GAAGT,UAAU,CAACQ,cAAc,CAACC,OAAhB,CAA1B;AACA,WAAOA,OAAO,KAAKN,UAAnB;AACD,GAHiB,CAAlB;AAKA,SAAOC,SAAS,GAAGA,SAAS,CAACM,aAAb,GAA6B,IAA7C;AACD,CAPM;AASP;AACA;AACA;;AACA,OAAO,MAAMC,WAAW,GAAIC,QAAD,IAAsB;AAC/C;AACA;AACA;AAEA,SAAOA,QAAP;AACD,CANM;AAQP,OAAO,MAAMC,gBAAgB,GAAIC,IAAD,IAAmB;AACjD,SAAOd,UAAU,CAACD,UAAU,CAACe,IAAD,CAAV,CAAiBL,OAAlB,CAAjB;AACD,CAFM;AAIP,OAAO,MAAMM,eAAe,GAAG,OAAOZ,UAAP,EAA2Ba,OAA3B,KAA+C;AAC5E,MAAI;AACF,UAAMC,QAAQ,GAAGhB,iBAAiB,CAACE,UAAD,CAAlC;AACA,UAAMS,QAAQ,GAAG,MAAMK,QAAQ,CAACC,OAAT,CAAiBC,QAAjB,CAA0BH,OAA1B,EAAmCI,IAAnC,EAAvB;AACA,UAAMC,eAAe,GAAG,MAAMC,KAAK,CAACX,WAAW,CAACC,QAAD,CAAZ,CAAnC,CAHE,CAKF;AACA;AACA;;AAEA,UAAMW,OAAO,GAAG,MAAMF,eAAe,CAACG,IAAhB,EAAtB;AACA,WAAOD,OAAP;AACD,GAXD,CAWE,OAAOE,KAAP,EAAc;AACdC,IAAAA,OAAO,CAACD,KAAR,CAAc,iBAAd,EAAiCA,KAAjC;AACA,WAAO,IAAP;AACD;AACF,CAhBM;AAkBP,OAAO,MAAME,eAAe,GAAG,OAAOxB,UAAP,EAA2Ba,OAA3B,KAAoE;AACjG,QAAMO,OAAO,GAAG,MAAMR,eAAe,CAACZ,UAAD,EAAaa,OAAb,CAArC;AACA,QAAMN,aAAa,GAAGR,2BAA2B,CAACC,UAAD,CAAjD,CAFiG,CAIjG;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAGA;AACA;AACA;;AAEA,SAAOL,IAAI,CAACS,IAAL,CAAWqB,GAAD,IAAS;AACxB,WAAOA,GAAG,CAACC,UAAJ,KAAmB,QAA1B;AACD,GAFM,CAAP;AAGD,CA1BM","sourcesContent":["import Nfts, { IPFS_GATEWAY, nftSources } from 'config/constants/nfts'\nimport { Nft, NftType } from 'config/constants/types'\nimport { getAddress } from './addressHelpers'\nimport { getErc721Contract } from './contractHelpers'\n\n/**\n * Gets the identifier key based on the nft address\n * Helpful for looking up the key when all you have is the address\n */\nexport const getIdentifierKeyFromAddress = (nftAddress: string) => {\n  const nftSource = Object.values(nftSources).find((nftSourceEntry) => {\n    const address = getAddress(nftSourceEntry.address)\n    return address === nftAddress\n  })\n\n  return nftSource ? nftSource.identifierKey : null\n}\n\n/**\n * Some sources like Pancake do not return HTTP tokenURI's\n */\nexport const getTokenUrl = (tokenUri: string) => {\n  // if (tokenUri.startsWith('ipfs://')) {\n  //   return `${IPFS_GATEWAY}/ipfs/${tokenUri.slice(6)}`\n  // }\n  \n  return tokenUri\n}\n\nexport const getAddressByType = (type: NftType) => {\n  return getAddress(nftSources[type].address)\n}\n\nexport const getTokenUriData = async (nftAddress: string, tokenId: number) => {\n  try {\n    const contract = getErc721Contract(nftAddress)\n    const tokenUri = await contract.methods.tokenURI(tokenId).call()\n    const uriDataResponse = await fetch(getTokenUrl(tokenUri))\n\n    // if (!uriDataResponse.ok) {\n    //   return null\n    // }\n    \n    const uriData = await uriDataResponse.json()\n    return uriData\n  } catch (error) {\n    console.error('getTokenUriData', error)\n    return null\n  }\n}\n\nexport const getNftByTokenId = async (nftAddress: string, tokenId: number): Promise<Nft | null> => {\n  const uriData = await getTokenUriData(nftAddress, tokenId)\n  const identifierKey = getIdentifierKeyFromAddress(nftAddress)\n  \n  // Bail out early if we have no uriData, identifierKey, or the value does not\n  // exist in the object\n  // if (!uriData) {\n  //   return null\n  // }\n\n  // if (!identifierKey) {\n  //   return null\n  // }\n\n  // if (!uriData[identifierKey]) {\n  //   return null\n  // }\n\n  \n  // return Nfts.find((nft) => {\n  //   return uriData[identifierKey].includes(nft.identifier)\n  // })\n\n  return Nfts.find((nft) => {\n    return nft.identifier === 'Dragon'\n  })\n}\n"]},"metadata":{},"sourceType":"module"}