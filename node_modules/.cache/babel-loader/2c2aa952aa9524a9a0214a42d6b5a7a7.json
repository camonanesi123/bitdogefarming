{"ast":null,"code":"import _defineProperty from\"D:/task159/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/defineProperty\";import _toConsumableArray from\"D:/task159/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";import _objectSpread from\"D:/task159/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread2\";import _slicedToArray from\"D:/task159/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";import _regeneratorRuntime from\"D:/task159/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";import _asyncToGenerator from\"D:/task159/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";/* eslint-disable no-param-reassign */import{createAsyncThunk,createSlice}from'@reduxjs/toolkit';import{nftSources}from'config/constants/nfts';import{getAddress}from'utils/addressHelpers';import{getErc721Contract}from'utils/contractHelpers';import{getNftByTokenId}from'utils/collectibles';var initialState={isInitialized:false,isLoading:true,data:{}};// Thunks\nexport var fetchWalletNfts=createAsyncThunk('collectibles/fetchWalletNfts',/*#__PURE__*/function(){var _ref=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee3(account){var nftSourcePromises,nftSourceData;return _regeneratorRuntime.wrap(function _callee3$(_context3){while(1){switch(_context3.prev=_context3.next){case 0:// For each nft source get nft data\nnftSourcePromises=Object.keys(nftSources).map(/*#__PURE__*/function(){var _ref2=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee2(nftSourceType){var addressObj,address,contract,getTokenIdAndData,balanceOfResponse,balanceOf,nftDataFetchPromises,i,nftData;return _regeneratorRuntime.wrap(function _callee2$(_context2){while(1){switch(_context2.prev=_context2.next){case 0:addressObj=nftSources[nftSourceType].address;address=getAddress(addressObj);contract=getErc721Contract(address);getTokenIdAndData=/*#__PURE__*/function(){var _ref3=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee(index){var tokenId,walletNft;return _regeneratorRuntime.wrap(function _callee$(_context){while(1){switch(_context.prev=_context.next){case 0:_context.prev=0;_context.next=3;return contract.methods.tokenOfOwnerByIndex(account,index).call();case 3:tokenId=_context.sent;_context.next=6;return getNftByTokenId(address,tokenId);case 6:walletNft=_context.sent;return _context.abrupt(\"return\",[Number(tokenId),walletNft.identifier]);case 10:_context.prev=10;_context.t0=_context[\"catch\"](0);console.error('getTokenIdAndData',_context.t0);return _context.abrupt(\"return\",null);case 14:case\"end\":return _context.stop();}}},_callee,null,[[0,10]]);}));return function getTokenIdAndData(_x3){return _ref3.apply(this,arguments);};}();_context2.next=6;return contract.methods.balanceOf(account).call();case 6:balanceOfResponse=_context2.sent;balanceOf=Number(balanceOfResponse);if(!(balanceOf===0)){_context2.next=10;break;}return _context2.abrupt(\"return\",[]);case 10:nftDataFetchPromises=[];// For each index get the tokenId and data associated with it\nfor(i=0;i<balanceOf;i++){nftDataFetchPromises.push(getTokenIdAndData(i));}_context2.next=14;return Promise.all(nftDataFetchPromises);case 14:nftData=_context2.sent;return _context2.abrupt(\"return\",nftData);case 16:case\"end\":return _context2.stop();}}},_callee2);}));return function(_x2){return _ref2.apply(this,arguments);};}());_context3.next=3;return Promise.all(nftSourcePromises);case 3:nftSourceData=_context3.sent;return _context3.abrupt(\"return\",nftSourceData.flat());case 5:case\"end\":return _context3.stop();}}},_callee3);}));return function(_x){return _ref.apply(this,arguments);};}());export var collectiblesSlice=createSlice({name:'collectibles',initialState:initialState,reducers:{},extraReducers:function extraReducers(builder){builder.addCase(fetchWalletNfts.pending,function(state){state.isLoading=true;});builder.addCase(fetchWalletNfts.fulfilled,function(state,action){state.isLoading=false;state.isInitialized=true;state.data=action.payload.reduce(function(accum,association){if(!association){return accum;}var _ref4=association,_ref5=_slicedToArray(_ref4,2),tokenId=_ref5[0],identifier=_ref5[1];return _objectSpread(_objectSpread({},accum),{},_defineProperty({},identifier,accum[identifier]?[].concat(_toConsumableArray(accum[identifier]),[tokenId]):[tokenId]));},{});});}});export default collectiblesSlice.reducer;","map":{"version":3,"sources":["D:/task159/frontend/src/state/collectibles/index.ts"],"names":["createAsyncThunk","createSlice","nftSources","getAddress","getErc721Contract","getNftByTokenId","initialState","isInitialized","isLoading","data","fetchWalletNfts","account","nftSourcePromises","Object","keys","map","nftSourceType","addressObj","address","contract","getTokenIdAndData","index","methods","tokenOfOwnerByIndex","call","tokenId","walletNft","Number","identifier","console","error","balanceOf","balanceOfResponse","nftDataFetchPromises","i","push","Promise","all","nftData","nftSourceData","flat","collectiblesSlice","name","reducers","extraReducers","builder","addCase","pending","state","fulfilled","action","payload","reduce","accum","association","reducer"],"mappings":"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","sourcesContent":["/* eslint-disable no-param-reassign */\nimport { createAsyncThunk, createSlice } from '@reduxjs/toolkit'\nimport { CollectiblesState } from 'state/types'\nimport { nftSources } from 'config/constants/nfts'\nimport { NftType } from 'config/constants/types'\nimport { getAddress } from 'utils/addressHelpers'\nimport { getErc721Contract } from 'utils/contractHelpers'\nimport { getNftByTokenId } from 'utils/collectibles'\n\nconst initialState: CollectiblesState = {\n  isInitialized: false,\n  isLoading: true,\n  data: {},\n}\n\ntype NftSourceItem = [number, string]\n\n// Thunks\nexport const fetchWalletNfts = createAsyncThunk<NftSourceItem[], string>(\n  'collectibles/fetchWalletNfts',\n  async (account) => {\n    // For each nft source get nft data\n    const nftSourcePromises = Object.keys(nftSources).map(async (nftSourceType) => {\n      const { address: addressObj } = nftSources[nftSourceType as NftType]\n      const address = getAddress(addressObj)\n\n      const contract = getErc721Contract(address)\n\n      const getTokenIdAndData = async (index: number) => {\n        try {\n          const tokenId = await contract.methods.tokenOfOwnerByIndex(account, index).call()\n          const walletNft = await getNftByTokenId(address, tokenId)\n          return [Number(tokenId), walletNft.identifier]\n        } catch (error) {\n          console.error('getTokenIdAndData', error)\n          return null\n        }\n      }\n\n      const balanceOfResponse = await contract.methods.balanceOf(account).call()\n      const balanceOf = Number(balanceOfResponse)\n\n      if (balanceOf === 0) {\n        return []\n      }\n\n      const nftDataFetchPromises = []\n\n      // For each index get the tokenId and data associated with it\n      for (let i = 0; i < balanceOf; i++) {\n        nftDataFetchPromises.push(getTokenIdAndData(i))\n      }\n\n      const nftData = await Promise.all(nftDataFetchPromises)\n      return nftData\n    })\n\n    const nftSourceData = await Promise.all(nftSourcePromises)\n\n    return nftSourceData.flat()\n  },\n)\n\nexport const collectiblesSlice = createSlice({\n  name: 'collectibles',\n  initialState,\n  reducers: {},\n  extraReducers: (builder) => {\n    builder.addCase(fetchWalletNfts.pending, (state) => {\n      state.isLoading = true\n    })\n    builder.addCase(fetchWalletNfts.fulfilled, (state, action) => {\n      state.isLoading = false\n      state.isInitialized = true\n      state.data = action.payload.reduce((accum, association) => {\n        if (!association) {\n          return accum\n        }\n\n        const [tokenId, identifier] = association as NftSourceItem\n\n        return {\n          ...accum,\n          [identifier]: accum[identifier] ? [...accum[identifier], tokenId] : [tokenId],\n        }\n      }, {})\n    })\n  },\n})\n\nexport default collectiblesSlice.reducer\n"]},"metadata":{},"sourceType":"module"}